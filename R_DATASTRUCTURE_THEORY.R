# ----------------------------- DATA STRUCTURE ---------------------------------

# [ 참고 11 : R과 Python의 자료 구조 비교 ]
#   R             Python
# 벡터            리스트
# 리스트          딕셔너리          => key 구조
# 행열            행열
# 배열            배열
# 데이터프레임    데이터프레임      => key 구조

# 1. 벡터
# - 1차원
# - 여러개 값을 동시에 담거나 전달하기 위해 사용
# - 하나의 데이터 타입만 허용
# - 데이터프레임(테이블) 내 컬럼의 구조이기도 함

# 1.1 생성
v1 <- c(1, 2, 3) ; v1
v2 <- c(1, 2, 'a') ; v2
v3 <- 1:10 ; v3    # 여러개 만들면 자동으로 벡터가 됨

# 1.2 확장
# 1)
c(c(1, 2, 3), 4)    # 1 2 3 4 => 벡터에 벡터를 넣어도 계속 1차원으로 쭉 풀림

c(v1, 4)            # 위 특성 활용하면 벡터의 확장이 가능

# 2) append 
append(x,                    # 벡터
       values = ,            # 추가 값
       after = length(x))    # 위치 => 몇번째 뒤에, 생략 시 맨 뒤
append(v1, 4)
append(v1, 4, after = 1)     # 1번째 뒤에

# 1.3 산술연산
v1 <- c(1, 2, 3)
v2 <- c(10, 20, 30)
v3 <- c(10, 20, 30, 40)

v1 + 1    # 벡터와 숫자 산술연산 가능
v1 + v2   # 동일한 크기의 벡터는 같은 위치 원소끼리 연산
v1 + v3   # 서로 다른 크기의 벡터의 연산은 작은 크기의 벡터가                   # *
# 반복되면서 연산됨
# 10 20 30 40
# 1  2  3  1 
# ===========
# 11 22 33 41

# 1.4 색인(indexing) ***** => Python에서도 같음
# 1) 정수 색인 => 위치 색인
v_sal <- c(800, 900, 1000, 1100, 1200)
v_sal[1]
v_sal[1, 3]     # Error => 2차원 색인 : 1번째 행의 3번째 컬럼만 선택            # *
v_sal[c(1, 3)]  # 1, 3번째 원소 추출

# 2) 이름 색인                                                                  # *
names(v_sal)         # 이름이 뭐야? NULL (미지정)
# 각 원소의 이름 어떻게 지정? 마치 컬럼명을 만드는 것
names(v_sal) <- c('a', 'b', 'c', 'd', 'e') ; v_sal
v_sal['a']           # a라는 행에 매칭되는 원소는?
v_sal[c('a', 'd')]

# 3) 슬라이스 색인
v_sal[c(1, 2, 3)]
v_sal[1:3]
v_sal[2:5]

# 4) 조건 색인(boolean indexing)
# Oracle에서는 컬럼에 조건을 넣을 수는 없었으나 R, Python에서는 가능
v_sal >= 1000            
v_sal[v_sal >= 1000]     # oracle의 where절과 같은 개념
v_sal[c(F, F, T, T, T)]  # 위와 같은 결과

# 1.5 벡터 수정
v_sal[2]
v_sal[2] <- 1100

# 1.6 벡터의 크기 확인
length(v_sal)    # 벡터의 크기 확인하는 함수, 각 벡터의 원소의 개수, 컬럼의 개수
NROW(v_sal)      # 벡터의 원소의 개수, 2차원의 행의 수
nrow(v_sal)      # 2차원 데이터의 행의 수

length(df1)
NROW(df1)
nrow(df1)

# 1.7 벡터의 집합 연산자                                                        # *
# 1) 합집합 : union
# 2) 차집합 : setdiff
# 3) 교집합 : intersect
# 4) 동등비교 : identical, setequal

v1 <- c(1, 2, 3, 4, 5)
v2 <- c(1, 2, 30, 40, 50)
v3 <- c(1, 2, 3, 4, 5, 6)
v4 <- c(1, 2, 3, 4, 5, 5)

union(v1, v2)        # 1 2 3 4 5 30 40 50
c(v1, v2)            # union all

intersect(v1, v2)    # 1 2
setdiff(v1, v2)      # 3 4 5

identical(v1, v3)    # FALSE => 크기 다르고 서로 다른 원소가 있으므로
setequal(v1, v3)     # FALSE => 서로 다른 원소가 있으므로

identical(v1, v4)    # FALSE => 구성 원소는 같으나 크기가 달라서
setequal(v1, v4)     # TRUE => 크기 상관 없이 구성 원소만 같으면
# ------------------------------------------------------------------------------

# 2. 리스트                                                                     # *
# - 1차원
# - key 구조 (데이터를 빠르게 검색/저장할 수 있도록 만든 자료구조)
# - 서로 다른 데이터 타입 허용

# 2.1 생성
l1 <- list('name' = '홍길동', 'tel' = '02)043-0875', 'addr' = '서울시')
l2 <- list('name' = '홍길동', 'tel' = '02)043-0875', 'addr' = '서울시', 'sal' = 4000)
l3 <- list('name' = c('홍길동', '김길동'),
           'tel' = c('02)043-0875', '031)384-3944'),
           'addr' = c('서울시', '경기도'),
           'sal' = c(4000, 3900))
# 각 key를 구성하는 데이터 타입 : 벡터

# 2.2 색인                                                                      # **
l3[1]           # 1번째 key(층) 선택
l3[c(1, 3)]     # 1, 3번째 key(층) 선택

l3['name']
l3[c('name', 'tel')]

l3$name
l3$c(name, tel) # 불가, key 색인은 하나의 key만 전달 가능

# 2.3 수정
l3$name[2] <- '최길동' ; l3

l3$comm <- c(500, 400)          # key 추가 1
df1$new_sal <- df1$SAL * 1.1    # key 추가 2
l3$comm <- NULL ; l3            # key 삭제

# key를 갖는 자료형태
'name' : '홍길동'
'tel'  : '02)043-0875'
'addr' : '서울시'

# key를 갖지 않는 자료형태
'홍길동', '02)043-0875', '서울시'
# ------------------------------------------------------------------------------

# 3. 행렬 : matrix                                                              # *
# - 2차원
# - 하나의 데이터 타입만 허용
# - 주로 숫자 연산을 빠르게 하기 위해 만듦

# 3.1 생성
matrix(data = ,               # matrix 구성 data
       nrow = ,               # 행 수
       ncol = ,               # 컬럼 수
       byrow = FALSE,         # 행 우선순위 배치 여부
       dimnames = )           # 행과 열의 이름, 반드시 리스트로 전달

m1 <- matrix(1:9, nrow = 3, ncol = 3) ; m1
m1 <- matrix(1:9, nrow = 3) ; m1               # 당연한 건 쓰지 않아도 됨
m2 <- matrix(1:9, nrow = 3, byrow = T) ; m2    # 행부터 완성
m3 <- matrix(1:9, 
             nrow = 3, 
             byrow = T,
             dimnames = list(c('a', 'b', 'c'),
                             c('A', 'B', 'C'))) ; m3

# 3.2 색인
m1[1, 1]
m1[, 1]
m1[1, ]
m1[, c(2, 3)]    # 2, 3번째 컬럼만
m1[, 2:3]
m1[, -1]         # 1번째 컬럼 제외
m3['a', 'A']     # 이름이 있는 경우 이름색인 가능
m1[m1 > 5]       # 6 7 8 9 => 2차원 형식의 boolean을 색인에 그대로 전달

m1[, 1]                    # 벡터, 1차원, 차원의 축소 발생                      # *
m1[, 1, drop = F]          # 2차원 출력, 차원축소 발생 x

# 3.3 수정
m1[1, 1] <- 10

# 3.4 구조변경                                                                  # *
# 1) 행, 열 이름 변경
rownames(m2) <- c('a', 'b', 'c')
colnames(m2) <- c('A', 'B', 'C')
dimnames(m2) <- list(c('a', 'b', 'c'), c('A', 'B', 'C'))

# 2) 행, 열 추가                                                      
m2[, 4] <- c(10, 20, 30)                  # Error => 기존 범위를 벗어나서 불가
m3 <- cbind(m2, c(10, 20, 30))            # m2 맨 뒤에 컬럼 추가
cbind(m2[, 1], c(10, 20, 30), m2[, 2:3])  # 중간 삽입 시  

rbind(m2, c(10, 11, 12))                  # 행 삽입

# 3.5 연산                                                                      # *
m1 <- matrix(1:4, nrow = 2)
m2 <- matrix(seq(10, 40, 10), nrow = 2)
m3 <- matrix(1:9, nrow = 3)
m1 * m2    # 각 원소마다 곱하기 연산
m1 %*% m2  # matrix inner product 행렬 곱

m1 + m2    # 크기가 같은 행렬끼리 연산 가능
m1 + m3    # 크기가 다른 행렬끼리 연산 불가

# [ 참고 12 : 행렬 곱 ]
[a1, a2     [b1, b2
             a3, a4]     b3, b4]

(2 x 2) * (2 x 2) = (2 x 2)
(3 x 2) * (2 x 6) = (3 x 6)

(a1 * b1 + a2 * b3)    (a1 * b2 + a2 * b4)
(a3 * b1 + a4 * b3)    (a3 * b2 + a4 * b4)

# 3.6 크기 확인                                                                 # *
nrow(m1)    # 행의 수 of 행렬
ncol(m1)   # 열의 수 of 행렬
NROW(m1)    # 행의 수 of 벡터
NCOL(m1)    # 열의 수 of 벡터
dim(m1)     # 2 x 2

m1 <- matrix(1:20, nrow = 5)
dim(m1)    # 5 x 4
dim(m1) <- c(4, 5)    # 4 x 5, matrix reshape
m1
# ------------------------------------------------------------------------------

# 4. 배열                                                                       # *
# 4.1 생성
array(data = ,        # 배열을 구성하는 data(벡터)
      dim = ,         # 차원(벡터로 전달)
      dimnames = )    # 각 차원의 이름(리스트로 전달)
array(1:18, dim = c(2, 3, 3))  # 차원은 행, 열, 층, ... 순서
array(1:18,
      dim = c(2, 3, 3),
      dimnames = list(c('a', 'b'), c('A', 'B', 'C'), c('1F', '2F', '3F')))

# [ 참고 13 : 다차원의 배열 순서 비교 ]
# in R)
# 행 열 층 ...

# in Python)
# ... 층 행 열

# 4.2 색인
a1 <- array(1:18, dim = c(3, 3, 2)) ; a1
a1[ , , 1]
a1[, , 1, drop = F]    # 사용 가능
a1[1, , ]
a1[1, , drop = F]      # Error => 사용 불가 => 모양이 바뀐 상태라 불가능
# array 구조에서는 drop = F 잘 사용하지 않음 => matrix에서 가장 많이 사용
# ------------------------------------------------------------------------------

# 5. 데이터 프레임                                                              # *
# - 2차원 구조
# - 행과 열의 구조
# - 열은 KEY를 갖는 구조
# - 엑셀에서의 표, 데이터베이스에서의 테이블과 비슷

# 5.1 생성
data.frame(...,                        # data 자리 => key-value 구조 나열
           row.names = ,               # row 이름
           stringsAsFactors = T)       # 문자의 팩터화 여부

df1 <- data.frame(ename = c('smith', 'david'),
                  sal = c(800, 900))
df2 <- data.frame(ename = c('smith', 'david'),
                  sal = c(800, 900),
                  row.names = c('a', 'b'))

# 5.2 구조확인
ncol(df1)         # 열의 수
nrow(df1)         # 행의 수
dim(df1)          # 행과 열의 수

rownames(df1)     # 행 이름
colnames(df1)     # 열 이름

str(df1)    # oracle의 desc와 유사

# 5.3 색인
df1[1, 1]                       # 위치(정수) 색인
df1[1, 'ename']                 # 이름 색인
df1[ , 'ename']                 # 특정 컬럼 하나의 선택은 차원 축소 됨
df1[, 'ename', drop = F]        # 차원 축소 방지 가능
df1$ename                       # key 색인

# 5.4 구조변경
# 1) 행 추가
df2 <- rbind(df1, c('harry', 1000, 300))    
# Error 1 => 3) 참조 : factor로 되어 있는 ename 컬럼에 최길동이 들어올 수 없음
# Error 2 => rbind로 행추가 시 벡터로 묶었기 때문에 3개가 문자로 데이터타입 변경

df2[3, 1] <- '최길동'    # Error => same
str(df1)    # ename은 factor로 나옴 => smith, harry 중에 나와야 함

# [ factor로 생성된 컬럼에 값을 추가하는 방법 ]
# 1. factor의 레벨을 수정
# 2. non factor변수로 수정                                                      
df2$ename <- as.character(df2$ename) 
str(df2)
df2[3, 1] <- '최길동'
df2$ename <- as.factor(df2$ename)

# 2) 컬럼 추가
df1$comm <- c(100, 200) ; df1          # 컬럼 추가 1 (key)
cbind(df1, 'empno' = c(9411, 9511))    # 컬럼 추가 2 (cbind)

# 3) factor형 변수
# 정해져 있는 레벨을 갖는 경우의 범주형 변수로 주로 문자형 컬럼일 경우 생성
# ex) 성별 : 남, 여 => 각각을 level이라고 표현
#     학점 : A, B, C, D
#     학년 : 1, 2, 3, 4
str(df1)    # ename은 factor로 나옴 => smith, harry 중에 나와야 함
# ------------------------------------------------------------------------------
reviewed 1, 2020-09-13